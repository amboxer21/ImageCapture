
1) Use __getattr__ to clean up config_dict calls.
Python has these things called magic methods and I wanted to implement some. That's what led me to the __getattr__ method and it looks pretty cool!

>>> class ConfigList():
...     def __init__(self):
...         self.data = {'one': '1', 'two': '2'}
...     def __getattr__(self,attr):
...         return self.data[attr]
... 
>>> ConfigList().one
'1'
so I could probably use that to clean up the config_dict calls!!!!!!
what do you think?
Should have called it ConfigDict

----------

>>> class TestClass:
...     def __init__(self):
...         self.data = {'one': '1', 'two': '2', 'five': '5'}
...     def __setattr__(self, name, value):
...         print("" + self.data.__dict__[name])
...         self.data.__dict__[name] = value.upper()
... 
>>> f = TestClass
>>> f.one = '9'
>>> f.one
'9'

-------------

class MyClass(object):

    def __init__(self):
        # prevents infinite recursion from self.data = {'a': 'v1', 'b': 'v2'}
        # as now we have __setattr__, which will call __getattr__ when the line
        # self.data[k] tries to access self.data, won't find it in the instance 
        # dictionary and return self.data[k] will in turn call __getattr__
        # for the same reason and so on.... so we manually set data initially
        super(MyClass, self).__setattr__('data', {'a': 'v1', 'b': 'v2'})

    def __setattr__(self, k, v):
        self.data[k] = v

    def __getattr__(self, k):
        # we don't need a special call to super here because getattr is only 
        # called when an attribute is NOT found in the instance's dictionary
        try:
            return self.data[k]
        except KeyError:
            raise AttributeError
